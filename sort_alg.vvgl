library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
 
entity sort_alg is

  port (
    rst : in std_logic;
    clk      : in std_logic;
 
    -- Inputs
    ain_tvalid   : in  std_logic;
    ain_tready	 : in  std_logic;
    ain_tdata 	 : in  std_logic_vector(15 downto 0);
    ain_tlast    : in  std_logic;
 
    -- Outputs
   	aout_tvalid  : out std_logic;
    aout_tready  : out std_logic;
    aout_tdata   : out std_logic_vector(15 downto 0);
    aout_tlast   : out std_logic
    );
end sort_alg;
 
architecture rtl of sort_alg is
  -- Memory
  type data_array is array (0 to 1023) of std_logic_vector(15 downto 0); -- max number of transactions is 1024
  signal data, sort_data : data_array := (others => (others => '0'));
   -- States for FSM
  type state_type is (idle,transfer, increment_t, assign, compare, check, increment, drive_tvalid, drive_tready, drive_tdata);
  signal curr_state, next_state: state_type;
  -- Local signals
  signal i, j, d, x: integer := 0; -- Increment integers
  signal count: integer range 0 to 1023; -- field for number of transactions
  signal tmp_i, tmp_j: std_logic_vector(15 downto 0); -- Signals for temp values of data(i) and data(i+1)
  -- Local signals for driving data
  signal drive_ready, drive_valid, drive_data, drive_done: std_logic;
   
  begin
  
  	process(clk, rst) is 
    begin
    if(rst = '1') then
    	curr_state <= idle;
    	d <= 0;
    	count <= 0;
    	data <= (others => (others => '0'));
    	drive_done <= '0';
    	aout_tdata <= (others => '0');
    	aout_tvalid <= '0';
    	aout_tready <= '0';
    	aout_tlast <= '0';
    else
       if(rising_edge(clk)) then
    	curr_state <= next_state;
    	-- collecting data
        if((ain_tvalid = '1') and (ain_tready = '1') and ain_tlast = '0') then
            data(count) <= ain_tdata;
            count <= count + 1;
            drive_done <= '0';
	    end if;
	    -- driving valid signal
	    if(curr_state = drive_tvalid) then
	       aout_tvalid <= '1';
	    end if;
	    -- driving ready signal
	    if(curr_state = drive_tready) then
	       aout_tready <= '1';
        end if;
        -- driving data
	    if(curr_state = drive_tdata) then
               if(d /= count-1) then
                   aout_tdata <= sort_data(d);
                   d <= d + 1;
                   drive_done <= '0';
               else
                    aout_tdata <= sort_data(d);
                    aout_tlast <= '1';
                    drive_done <= '1';
               end if; 
	    end if;
	    -- driving data done
	    if(drive_done = '1') then
            aout_tlast <= '0';
            aout_tvalid <= '0';
            aout_tready <= '0';
            drive_done <= '1';
	    end if;
        end if;
    end if;
    end process;
    
    
     process(curr_state, ain_tlast, drive_done) is
    begin
    case curr_state is
        when idle =>
            tmp_i <= (others => '0');
            tmp_j <= (others => '0');
            drive_ready <= '0';
            sort_data <= (others => (others => '0'));
             if(ain_tlast = '1') then
                next_state <= transfer;
            else
                next_state <= idle;
            end if;
        when transfer =>
            sort_data(x) <= data(x);
            if(x /= count) then
                next_state <= increment_t;
            else
                next_state <= assign;
            end if;
        when increment_t =>
            x <= x + 1;
            next_state <= transfer;
        when assign =>
           tmp_i <= sort_data(i);
           tmp_j <= sort_data(i+1);
           next_state <= compare;
        when compare =>
            if(tmp_i > tmp_j) then
                sort_data(i+1) <= tmp_i;
                sort_data(i) <= tmp_j;
                next_state <= increment;
            else
                next_state <= increment;
            end if;
        when increment =>
            if(j /= count-2) then
                i <= i+1;
                next_state <= check;
            else
                next_state <= drive_tvalid;
            end if;
            if(i = count-2) then
                j <= j+1;
            end if;
        when check =>
                if(i = count-1) then
                    i <= 0;
                    next_state <= assign;
                else
                    next_state <= assign;
                end if;
        when drive_tvalid =>
            drive_valid <= '1';
            next_state <= drive_tready;
        when drive_tready =>
            drive_ready <= '1';
            next_state <= drive_tdata;
        when drive_tdata =>
            if(drive_done = '1') then
                next_state <= idle;
                drive_data <= '0';
                drive_ready <= '0';
                drive_valid <= '0';
            else
                drive_data <= '1';
            end if;
    end case;
    end process;
end rtl;
